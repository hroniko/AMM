/**
 * Created by Hroniko on 13.10.2016.
 */
// Класс бинарного АВР-дерева
public class Tree <T extends  Comparable> { // Делаем через дженерики для более обобщенного вида класса
    // Поля класса:
    public T key; // Ключ узла
    public int height; // Высота узла
    // public String info; // Информационное поле, пока не используется
    // public double element; // Вещественное значение, пока не используется
    public Tree left; // Левый потомок (ссылка на объект класса Дерево)
    public Tree right; // Правый потомок (ссылка на объект класса Дерево)

    // Методы классса:

    // Метод поиска узла по его индексу в дереве, начинающемуся с данного корня root:
    private Tree<T> findNode(Tree<T> root, T x){
        if (root == null){ // Если больше нет элементов,
            return null; // возвращем пустую ссылке
        }
        if (root.key == x){ // Если ключи совпали,
            return root; // возвращаем ссылку на текущий элемент
        }
        if (root.key.compareTo(x) == 1){ // Если ключ корневого элемента больше искомого, то
            return findNode(root.left, x); // "сворачиваем" налево, то есть идем и ищем в левом потомке
        }
        else {
            return findNode(root.right, x); // Иначе идем и ищем в правом потомке
        }
    }
    // Метод поиска узла по его индексу в дереве, автоматически подхватывает сслку объекта на самого себя и передает в перегруженный метод выше:
    public Tree<T> findNode(T x){
        return findNode(this, x);
    }

    // -----------------------------------------------------------------------------
    // ПРЯМОЙ ОБХОД
    // Прямой порядок обхода (FrontOrder, DirectOrder, TopDownOrder, сверху вниз)
    // заключается в том, что корень некоторого дерева посещается раньше,
    // чем его поддеревья. Если после корня посещается его левое (правое)
    // поддерево, то обход называется прямым левым (правым) обходом.

    // 1) Метод прямого левого обхода с выводом ключей на консоль:
    public void frontOrderLeft(Tree<T> v){
        if (v == null){ // Если больше нет элементов,
            return ; // выходим из метода
        } // Иначе просто продолжаем выполнение:
        System.out.print(v.key + " "); // Напечатать значение ключа
        frontOrderLeft(v.left); // И идем в левую ветку
        frontOrderLeft(v.right); // И затем в правую ветку
    }
    // 1.1) Метод прямого левого обхода с выводом ключей на консоль (с подстановкой ссылки на сам объект)
    public void frontOrderLeft(){
        frontOrderLeft(this);
    }

    // 2) Метод прямого правого обхода с выводом ключей на консоль:
    public void frontOrderRight(Tree<T> v){
        if (v == null){ // Если больше нет элементов,
            return ; // выходим из метода
        } // Иначе просто продолжаем выполнение:
        System.out.print(v.key + " "); // Напечатать значение ключа
        frontOrderRight(v.right); // И идем в правую ветку
        frontOrderRight(v.left); // И затем в левую ветку
    }
    // 2.1) Метод прямого правого обхода с выводом ключей на консоль (с подстановкой ссылки на сам объект)
    public void frontOrderRight(){
        frontOrderRight(this);
    }

    // -----------------------------------------------------------------------------
    // ОБРАТНЫЙ ОБХОД
    // Обратный порядок обхода (BackOrder, DownTopOrder, снизу вверх)
    // заключается в том, что корень дерева посещается после его поддеревьев.
    // Если сначала посещается левое (правое) поддерево корня,
    // то обход называется обратным левым (правым) обходом.

    // 3) Метод обратного левого обхода с выводом ключей на консоль:
    public void backOrderLeft(Tree<T> v){
        if (v == null){ // Если больше нет элементов,
            return ; // выходим из метода
        } // Иначе просто продолжаем выполнение:
        backOrderLeft(v.left); // И идем в левую ветку
        backOrderLeft(v.right); // И затем в правую ветку
        System.out.print(v.key + " "); // Напечатать значение ключа
    }
    // 3.1) Метод обратного левого обхода с выводом ключей на консоль (с подстановкой ссылки на сам объект)
    public void backOrderLeft(){
        backOrderLeft(this);
    }

    // 4) Метод обратного правого обхода с выводом ключей на консоль:
    public void backOrderRight(Tree<T> v){
        if (v == null){ // Если больше нет элементов,
            return ; // выходим из метода
        } // Иначе просто продолжаем выполнение:
        backOrderRight(v.right); // И идем в правую ветку
        backOrderRight(v.left); // И затем в левую ветку
        System.out.print(v.key + " "); // Напечатать значение ключа
    }
    // 4.1) Метод прямого правого обхода с выводом ключей на консоль (с подстановкой ссылки на сам объект)
    public void backOrderRight(){
        backOrderRight(this);
    }

    // -----------------------------------------------------------------------------
    // ВНУТРЕННИЙ ОБХОД
    // Внутренний порядок обхода (InnnerOrder, слева направо или справа налево)
    // заключается в том, что корень посещается после посещения одного из его
    // поддеревьев. Если корень посещается после посещения его левого (правого)
    // поддерева, то обход называется внутренним левым (правым) обходом. Заметим,
    // что внутренний левый (правый) обход посещает вершины дерева в порядке
    // возрастания (убывания) ключей вершин.

    // 5) Метод левого внутреннего обхода с выводом ключей на консоль:
    public void innerOrderLeft(Tree<T> v){
        if (v == null){ // Если больше нет элементов,
            return ; // выходим из метода
        } // Иначе просто продолжаем выполнение:
        innerOrderLeft(v.left); // И идем в левую ветку
        System.out.print(v.key + " "); // Напечатать значение ключа
        innerOrderLeft(v.right); // И затем в правую ветку
    }
    // 5.1) Метод левого внутреннего обхода с выводом ключей на консоль (с подстановкой ссылки на сам объект)
    public void innerOrderLeft(){
        innerOrderLeft(this);
    }

    // 6) Метод правого внутреннего обхода с выводом ключей на консоль:
    public void innerOrderRight(Tree<T> v){
        if (v == null){ // Если больше нет элементов,
            return ; // выходим из метода
        } // Иначе просто продолжаем выполнение:
        innerOrderRight(v.right); // И идем в правую ветку
        System.out.print(v.key + " "); // Напечатать значение ключа
        innerOrderRight(v.left); // И затем в левую ветку
    }
    //6.1) Метод правого внутреннего обхода с выводом ключей на консоль (с подстановкой ссылки на сам объект)
    public void innerOrderRight(){
        innerOrderRight(this);
    }

    // -----------------------------------------------------------------------------
    // ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ
    // (АВР-деревья придуманы в 1962 году советскими учеными Адельсон-Вельским и Ландисом)

    // 9) Метод печати дерева в консоль с h отступами (рекурсивный)
    public void printTree(Tree<T> t, int h){
        if (t == null){ // Если больше нет элементов,
            return ; // выходим из метода
        } // Иначе просто продолжаем выполнение:
        printTree(t.left, h + 1);
        for(int j = 0; j <= h; j++){
            System.out.println("\t"); // Печатаем знаки табуляции
        }
        System.out.println(t.key + "\n");
        printTree(t.right, h + 1);
    }

    // -----------------------------------------------------------------------------
    // МЕТОДЫ ДЛЯ РЕАЛИЗАЦИИ АВЛ-ДЕРЕВЬЕВ, ВСТАВКА ЭЛЕМЕНТА
    // (АВР-деревья придуманы в 1962 году советскими учеными Адельсон-Вельским и Ландисом)

    // 10) Метод возрата высоты переданного узла:
    public int heightNode(Tree<T> t){
        return (t == null) ? 0 : t.height;
        // Если больше нет элементов, возвращаем 0 и выходим из метода.
        // Иначе просто продолжаем выполнение
    }
    // 10.1) Метод возрата высоты текущего узла:
    public int heightNode(){
        return heightNode(this);
    }

    // 11) Метод для вычисления balance factor заданного узла:
    public int balanceFactorNode(Tree<T> p){
        return (p == null) ? 0 : (heightNode(p.right) - heightNode(p.left));
    }
    // 11.1) Метод для вычисления balance factor текущего узла:
    public int balanceFactorNode(){
        return balanceFactorNode(this);
    }

    // 12) Метод восстановления корректного значения поля height заданного узла
    //(при условии, что значения этого поля в правом и левом дочерних узлах являются
    // корректными):
    public void fixHeight(Tree<T> p){
        if (p == null){ // Если больше нет элементов,
            return ; // выходим из метода
        }
        int hL = heightNode(p.left);
        int hR = heightNode(p.right);
        p.height = (hL > hR) ? hL + 1 : hR + 1;
    }
    // 12.1) Метод восстановления корректного значения поля height текущего узла
    public void fixHeight(){
        fixHeight(this);
    }

    // Балансировка узлов
    // В процессе добавления или удаления узлов в АВЛ-дереве возможно возникновение
    // ситуации, когда balance factor некоторых узлов оказывается равными 2 или -2,
    // т.е. возникает расбалансировка поддерева. Для выправления ситуации
    // применяются хорошо известные повороты вокруг тех или иных узлов дерева.

    // 13) Метод правого поворота вокруг узла p:
    public Tree<T> rotateRight(Tree<T> p){
        if (p == null){ // Если больше нет элементов,
            return p; // выходим из метода
        }
        Tree<T> q = p.left;
        p.left = q.right;
        q.right = p;
        fixHeight(p);
        fixHeight(q);
        return q;
    }
    // 13.1) Метод правого поворота вокруг текущего узла:
    public Tree<T> rotateRight(){
        return rotateRight(this);
    }

    // 14) Метод левого поворота вокруг узла p:
    public Tree<T> rotateLeft(Tree<T> q){
        if (q == null){ // Если больше нет элементов,
            return q; // выходим из метода
        }
        Tree<T> p = q.right;
        q.right = p.left;
        p.left = q;
        fixHeight(q);
        fixHeight(p);
        return p;
    }
    // 14.1) Метод левого поворота вокруг текущего узла:
    public Tree<T> rotateLeft(){
        return rotateLeft(this);
    }

    // 15) Метод балансировки веток при дисбалансе:
    public Tree<T> balanceNode(Tree<T> p){ // Балансировка узла p
        if (p == null) return p;  // Если больше нет элементов, выходим из метода // Балансировка не нужна
        fixHeight(p);
        if ( (balanceFactorNode(p) == 2) && (balanceFactorNode(p.right) < 0)) {
            p.right = rotateRight(p.right);
            return rotateLeft(p);
        }
        if ( (balanceFactorNode(p) == -2) && (balanceFactorNode(p.left) > 0) ){
            p.left = rotateLeft(p.left);
            return rotateRight(p);
        }
        return p; // Балансировка не нужна
    }
    // 15.1) Метод балансировки веток при дисбалансе для текущего узла:
    public Tree<T> balanceNode(){
        return balanceNode(this);
    }

    // 16) Метод вставки ключа k в дерево с корнем p
    public Tree<T> insertKey(Tree<T> p, T k){
        if (p == null){
            p = new Tree<T>();
            p.key = k;
            p.height = 0;
            p.left = p.right = null;
            return p;
        }
        else {
            if (p.key.compareTo(k) == 1) p.left = insertKey(p.left, k); // Если ключ переданного элемента больше нового
            else p.right = insertKey(p.right, k);
            return balanceNode(p);
        }
    }


    // -----------------------------------------------------------------------------
    // МЕТОДЫ ДЛЯ РЕАЛИЗАЦИИ АВЛ-ДЕРЕВЬЕВ, УДАЛЕНИЕ ЭЛЕМЕНТА
    // 17) Вспомогательный метод поиска узла с минимальным ключем в дереве p
    // (поиск от заданного элемента)
    public Tree<T> findMinNode(Tree<T> p){
        return (p.left == null) ? p : findMinNode(p.left);
    }
    // 17.1) Вспомогательный метод поиска узла с минимальным ключем в дереве p
    // (поиск от текущего элемента)
    public Tree<T> findMinNode(){
        return findMinNode(this);
    }

    // 18) Служебный метод для удаления минимального элемента из заданного дерева:
    // (поиск от заданного элемента)
    public Tree<T> removeMinNode(Tree<T> p){
        if (p.left == null) return p.right;
        p.left = removeMinNode(p.left);
        return  balanceNode(p);
    }
    // 18.1) Служебный метод для удаления минимального элемента из заданного дерева:
    // (поиск от текущего элемента)
    public Tree<T> removeMinNode(){
        return removeMinNode(this);
    }
}
