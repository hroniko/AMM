///////////////////////////////////////////////
// Программа  расчета   суммы  N  слагаемых  //
// заданного вида                            //
// Автор: Anatoly                            //
// ПММ, 1 курс, В/О, гр. 12,  3 вариант      //
// 2015-09-27                                //
///////////////////////////////////////////////

unit Unit1;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, Math, ExtCtrls, jpeg;

type
  TForm1 = class(TForm)
    mmo_Result: TMemo;
    grp1: TGroupBox;
    grp2: TGroupBox;
    grp3: TGroupBox;
    edt_X: TEdit;
    grp4: TGroupBox;
    edt_E: TEdit;
    grp5: TGroupBox;
    edt_N: TEdit;
    btn_OK: TButton;
    img1: TImage;
    mmo1: TMemo;
    procedure btn_OKClick(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.btn_OKClick(Sender: TObject);   // Процедура обработки нажатия кнопки
var X, E: Extended; // Переменные под значения Х и Е
    N: Integer; // Переменная под количество слагаемых
    E2: Extended;
    i, iSE, iSE2: Integer; // Счетчики для элементов суммы
    S: Extended; // Накопитель для суммы по всем элементам
    SE: Extended; // Накопитель для суммы по тем элементам, которые по абсолютному значению больше E
    SE2: Extended; // Накопитель для суммы по тем элементам, которые по абсолютному значению больше E/10
    P: Extended; // накопитель для слагаемого
    ST: Extended; // Переменная для хранения точного значения функции
    zakluchenie: string; // Текстовая переменная для хранения заключительной фразы
begin
//
    mmo_Result.Clear; // Очищаем многострочную текстовую панель
    // 1. Пытаемся прочитать из текстовых полей
    try
      X:= StrToFloat(edt_X.Text);
      N:= StrToInt(edt_N.Text);
      E:= StrToFloat(edt_E.Text);
    except
      mmo_Result.Lines.Add('Не удалось прочитать входные значения!');
      mmo_Result.Lines.Add('');
      mmo_Result.Lines.Add('Проверьте корректность введенных данных!');
      mmo_Result.Lines.Add('Значение Х должно быть вещественным числом из интервала (-1; 1)');
      mmo_Result.Lines.Add('Значение N должно быть натуральным числом (1, 2, 3, ...).');
      mmo_Result.Lines.Add('Значение E должно быть вещественным положительным числом.');
      mmo_Result.Lines.Add('В качестве разделителя целой и дробной части выступает ТОЧКА!');
      mmo_Result.Lines.Add('');
      mmo_Result.Lines.Add('ПРИМЕР: X=0.9, N=10, E=0.01');
      mmo_Result.Lines.Add('');
      mmo_Result.Lines.Add('Вычисления остановлены!');
      Exit // Выходим из подпрограммы
    end;

    // 2. Проверяем введенные данные:
    if (Abs(X)>=1) then
      begin
        mmo_Result.Lines.Add('Значения X превышают допустимый условиями задачи диапазон (-1; 1)');
        mmo_Result.Lines.Add('');
        mmo_Result.Lines.Add('Скорректируйте введенные данные!');
        mmo_Result.Lines.Add('');
        mmo_Result.Lines.Add('Вычисления остановлены!');
        Exit // и завершаем подпрограмму
      end;

    if (N<0) then
      begin
        mmo_Result.Lines.Add('Количество слагаемых N не может быть отрицательным!');
        mmo_Result.Lines.Add('');
        mmo_Result.Lines.Add('Скорректируйте введенные данные!');
        mmo_Result.Lines.Add('');
        mmo_Result.Lines.Add('Вычисления остановлены!');
        Exit // и завершаем подпрограмму
      end;

    if (E<=0) then
      begin
        mmo_Result.Lines.Add('Значение погрешности E не может быть отрицательным!');
        mmo_Result.Lines.Add('');
        mmo_Result.Lines.Add('Скорректируйте введенные данные!');
        mmo_Result.Lines.Add('');
        mmo_Result.Lines.Add('Вычисления остановлены!');
        Exit // и завершаем подпрограмму
      end;

    // 3. Если корректно прочитали значения, выполняем задание (а) и (b)- вычисляем сумму N слагаемых заданного вида:
    i:= 0; // Сбрасываем счетчик
	
	// а) Выполняем цикл по N
	    // Проверяем, какое число слагаемых ввел пользователь
    if N=0 then
      begin
        S:= 0; // Обнуляем сумму
      end
    else
      if N=1 then
        begin
          S:= X; // Заносим в первое слагаемое значение х
        end
      else
        begin
          P:= X; // Заносим в первое слагаемое значение х
          S:= P; // Заносим первое слагаемое в сумму

          // Запускаем цикл по всем слагаемым:
          while (i <= (N-2) ) do     // Для все элементов с певого до N считаем сумму по формуле
            begin
              P:= P * (-1) * Power( (2*i+1), 2 ) * Power( X, 2 ) / ( (2*i+2) * (2*i+3) ); // Вычисляем следующее слагаемое на основе предыдущего
              S:= S + P; // Увеличиваем сумму на значение текущего параметра

              i:= i + 1; // Делаем шаг по номеру слагаемого
            end;
        end;
		


	
	

    // Функцию ln(x+sqrt(x^2+1)) можно разложить в ряд Маклорена, причем каждое последующее слагаемое
    // можно получить домножением предыдущего слагаемого на (-1)*( (2n-1)^2 / (2n+2) ) * ( x^2 / (2n+3) )    См. расчеты в листочке))
    // При этом начинать надо со слагаемого х
	
// b) Выполняем цикл по E   
//--------------------------------------------------
  SE:= 0;
	iSE:= 0;
  P:= X; // Заносим в первое слагаемое значение х
	i:= -1;
    // Запускаем цикл по всем слагаемым:
    while (Abs(P) > E ) do     // Для все элементов с певого до большего, чем E, считаем сумму по формуле
      begin
	    SE:= SE + P; // Увеличиваем сумму на значение текущего параметра
		  i:= i + 1; // Делаем шаг по номеру слагаемого
		  P:= P * (-1) * Power( (2*i+1), 2 ) * Power( X, 2 ) / ( (2*i+2) * (2*i+3) ); // Вычисляем
      end;
    iSE:=i-1;
//-----------------------------------------------------	
// b2) Выполняем цикл по E2
    E2:=E/10; // На порядок меньше, чем исходное Е
    SE2:= 0;
    P:= X; // Заносим в первое слагаемое значение х
	  i:= -1;
    // Запускаем цикл по всем слагаемым:
    while (Abs(P) > E2 ) do     // Для все элементов с певого до большего, чем E, считаем сумму по формуле
      begin
	    SE2:= SE2 + P; // Увеличиваем сумму на значение текущего параметра
		  i:= i + 1; // Делаем шаг по номеру слагаемого
		  P:= P * (-1) * Power( (2*i+1), 2 ) * Power( X, 2 ) / ( (2*i+2) * (2*i+3) ); // Вычисляем
      end;	
    iSE2:=i-1;
//-----------------------------------------------------	
	
    // 4. Вычисляем точное значение функции:
    ST:= Ln(x + Sqrt(x*x+1) );

    
    // 5. Выводим в многострочное текстовое поле значение полученной суммы
    // mmo_Result.Lines.Add('Данная фигура не является треугольником!');
    // mmo_Result.Lines.Add('Сумма длин двух сторон не превышает длины третьей!');
    mmo_Result.Lines.Add('Вычисления выполнены!');
    mmo_Result.Lines.Add('');

    mmo_Result.Lines.Add('a) Сумма N слагаемых заданного вида составляет ' + FloatToStrF(S,fffixed,8,6) + ' при количестве слагаемых N = ' + IntToStr(N) + ';');
    mmo_Result.Lines.Add('');

    mmo_Result.Lines.Add('b) Сумма тех слагаемых, которые по абсолютной величине больше значения E, составляет ' + FloatToStrF(SE,fffixed,8,6) + ' при количестве слагаемых N = ' + IntToStr(iSE) + ' и погрешности E = ' + FloatToStrF(E,fffixed,8,6) + ';');
    mmo_Result.Lines.Add('');

    mmo_Result.Lines.Add('+) Сумма тех слагаемых, которые по абсолютной величине больше значения E2, меньшего на порядок, чем E, составляет ' + FloatToStrF(SE2,fffixed,8,6) + ' при количестве слагаемых N = ' + IntToStr(iSE2) + ' и погрешности E2 = ' + FloatToStrF(E2,fffixed,8,6) + ';');
    mmo_Result.Lines.Add('');

    mmo_Result.Lines.Add('+) Точное значение функции при заданном Х составляет ' + FloatToStrF(ST,fffixed,8,6));
    mmo_Result.Lines.Add('');

    // Сравниваем значение точной функции с приближенными вычислениями и выводим в зависимости от ситуации результат сравнения:
    if (ST>SE) then
      zakluchenie:= ('Это значение больше значения, полученного вычислением через разложение функции в ряд при заданной погрешности на ' + FloatToStrF((ST-SE),fffixed,8,6))
    else
      if (ST<SE) then
        zakluchenie:= ('Это значение меньше значения, полученного вычислением через разложение функции в ряд при заданной погрешности на ' + FloatToStrF((SE-ST),fffixed,8,6))
      else
        zakluchenie:= ('Это значение совпадает со значением, полученным вычислением через разложение функции в ряд при заданной погрешности');
    if (ST>SE2) then
      zakluchenie:=zakluchenie + (', а также больше значения, полученного вычислением через разложение функции в ряд (при уменьшенной погрешности) на ' + FloatToStrF((ST-SE2),fffixed,8,6))
    else
      if (ST<SE2) then
        zakluchenie:=zakluchenie + (', а также меньше значения, полученного вычислением через разложение функции в ряд (при уменьшенной погрешности) на ' + FloatToStrF((SE2-ST),fffixed,8,6))
      else
        zakluchenie:=zakluchenie + (', а также совпадает со значением, полученным вычислением через разложение функции в ряд (при уменьшенной погрешности)');
    mmo_Result.Lines.Add(zakluchenie); // Выводим сформированную строку
    // и прокручиваем скролл нашего многострочного текста к началу:
    mmo_Result.SelStart:=0;
    mmo_Result.SelLength := 0;
end;

end.
