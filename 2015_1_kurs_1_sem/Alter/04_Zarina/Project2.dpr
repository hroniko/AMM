program Project2;

{$APPTYPE CONSOLE}

uses
  SysUtils;
type masInt2 = array of array of Integer; // Объявляем новый тип - Двумерный массив целых чисел

var n, m: Integer; // Размерность матриц
    A: masInt2; // Объявляем экземпляр типа двумерного массива целых чисел для хранения матрицы А
    B: masInt2; // Объявляем экземпляр типа двумерного массива целых чисел для хранения матрицы B
    C: masInt2; // Объявляем экземпляр типа двумерного массива целых чисел для хранения матрицы C
    i, j: Integer; // Счетчики строк и столбцов

// Фнкция построчного чтения элементов матрицы из стандартного ввода
function ReadMatrix(Name: string): masInt2;  // Принимаемый параметр - строковая переменная = имя матрицы; рузельтат - двухмерный массив (матрица)
var ik, jk: Integer;   // счетчики по строкам и столбцам
    Matrix: masInt2;  // Промежуточная матрица, куда будем читать из кончоли элементы
begin
  SetLength(Matrix,n,m); // Выделяем память под динамический массив - матрицу (задаем ему размерность n x m)
  Writeln; // Для красоты делаем отступ на одну строку
  // Говорим пользователю, чтобы он вводим элементы матрицы А построчно, разделяя элементы пробелами, а в конце строчки жал энтер:
  Writeln('Vvedite matritcu ', Name, ' postrocno, razdelyaa elementi probelom: ');
  Writeln; // Для красоты делаем отступ на одну строку
  Writeln(Name, '= '); // Выводим имя текущей матрицы для получения элементов от пользователя
  // Запускаем цикл чтения и заполнения текущей матрицы:
  for ik:=0 to n-1 do     // Цикл по строкам
  begin
    for jk:=0 to m-1 do   // Цикл по столбцам
    begin
      read(Matrix[ik,jk]);  // Читаем текущий элемент
    end;
  end;
  Writeln; // Для красоты делаем отступ на одну строку
  Writeln(Name, ' ... OK!'); // Сообщаем, что все удачно прочитали и сформировали матрицу
  Result:= Matrix;  // Result - это встроенная перемнная текущей функции, по сути, ее синоним, т.е. здесь мы говорим, что результатом будет матрица - она будет на выходе функции
end;

// Функция проверки наличия передаваемого элемента из матрицы А в столбце матрицы В
// Выдает True, если элемента такого нет, и False, если элемент есть
function AinB(ia: Integer; ja: Integer; jb: Integer): Boolean; // номер элемента в матрице А, его i и j; номер столбца, по которому идет сравнение, в матрице B
var ib: Integer; // счетчик по строкам матрицы В
    flag: Boolean; // Флаг совпадения/несовпадения переданного элемента матрицы А с одним из элементов матрицы В
begin
  flag:= True; // Выствляем флаг в истину, т.е. подразумеваем пока, что совпадений нет и все хорошо
  // Запускаем цикл по строкам матрицы В (по фиксированному столбцу)
  for ib:= 0 to n-1 do
  begin
    if A[ia,ja] = B[ib,jb] then  // Если хоть какой-то элемент матрицы В совпадает с проверяемым элементом матрицы А,
    begin
      flag:= False; // То выставляем флаг в Ложь и
      Break; // выходим из цикла, т.к. дальше проверять нет смысла
    end;
  end;
  Result:= flag;  // Отправляем значение флага в результат функции
end;


// Функция суммирования с условием
// т.е. Функция формирования элемента матрицы С как суммы элементов строки матрица А, у которых нет совпадений с элементами столбца матрицы В
function SumMatrix(ia: Integer; jb: Integer): Integer;  // Принимаемые параметры - номер строки и номер столбца текущего элемента матрицы С
var ja: Integer;  // Счетчик по столбцам матрицы А
    Summa: Integer;  // Сумма разрешенных к сложению элементов текущей строки матрицы А
begin
  Summa:= 0;  // Обнуляем сумму
  // Запускаем цикл по столбцам матрицы А при фиксированной строке (т.е. по всем элементам текущей строки матрицы А)
  for ja:= 0 to m-1 do
  begin
    if AinB(ia, ja, jb)  // Проверяем условие несовпадения текущего элемента А(i,j) с любым из элементов строки матрицы В
    then Summa:= Summa + A[ia,ja]; // Если условие выполнено (нет совпадений), то кладем текущий элемент в сумму
  end;
  Result:= Summa; // После всех вычислений заносим сумму в результат функции
end;


// Собственно, тело основной программы:
begin
  { TODO -oUser -cConsole Main : Insert code here }
  // спашиваем у пользователя размерность матриц:
  write('Vvedite chislo strok, n: ');
  Readln(n);  // Читаем n
  write('Vvedite chislo stolbtcov, m: ');
  Readln(m); // Читаем m

  SetLength(A,n,m); // Выделяем память под динамический массив - матрицу А(задаем ему размерность n x m)
  SetLength(B,n,m); // Выделяем память под динамический массив - матрицу B(задаем ему размерность n x m)
  SetLength(C,n,m); // Выделяем память под динамический массив - матрицу C(задаем ему размерность n x m)

  A:= ReadMatrix('A'); // Вызываем функцию чтения матрицы А
  B:= ReadMatrix('B'); // Вызываем функцию чтения матрицы B

  // Запускаем цикл формирования элементов матрицы C:
  for i:=0 to n-1 do     // Цикл по строкам
  begin
    for j:=0 to m-1 do   // Цикл по столбцам
    begin
      C[i,j]:= SumMatrix(i,j);  // Каждый элемент C(i,j) есть результат работы функции суммирования с условием
    end;
  end;

  // Когда все посчитали, дальше выводим матрицу С на экран:

  Writeln; // Делаем отступ на одну строку для красивости
  Writeln('C= '); // Выводим надпись С равно
  // Запускам двойной цикл, в котором поэлементно вытаскиваем значения C(i,j) и выводим их на экран,
  // разделяя где нужно пробелами и делая переход на новую строку
  for i:=0 to n-1 do     // Цикл по строкам
  begin
    for j:=0 to m-1 do   // Цикл по столбцам
    begin
      write(C[i,j]);   // Выводим текущий элемент
      write(' ');  // Делаем отступ от элемента в виде пробела
    end;
    Writeln; // Переход на новую строку
  end;

  // осталось только дождаться ентера от пользователя:
  Readln; // Ждем подтверждения (продолжения)
  Readln; // Второй, т.к. первый может "проскочить"

end.
